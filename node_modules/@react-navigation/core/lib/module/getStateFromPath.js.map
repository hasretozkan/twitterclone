{"version":3,"sources":["getStateFromPath.tsx"],"names":["queryString","getStateFromPath","path","options","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","sort","config1","config2","pattern","split","length","remaining","replace","match","find","config","routeNames","every","name","c","screen","createNestedStateObject","parseQueryParams","parse","undefined","result","current","params","didMatch","matchParts","remainingParts","paramsIndex","paramPatterns","filter","p","startsWith","reduce","acc","i","value","substr","indexOf","segments","decodeURIComponent","shift","join","state","routes","index","route","findFocusedRoute","findParseConfigForRoute","routeConfig","initials","push","createConfigItem","screens","initialRouteName","connectedRoutes","forEach","nestedConfig","pop","routeName","flatConfig","findInitialRoute","includes","createStateObject","initialRoute","isEmpty","nestedState","parseConfig","query"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  screen: string;\n  match: string | null;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  // sort configs so the most exhaustive is always first to be chosen\n  configs.sort(\n    (config1, config2) =>\n      config2.pattern.split('/').length - config1.pattern.split('/').length\n  );\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  if (remaining === '') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.pattern === '' &&\n        config.routeNames.every(\n          // make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.pattern\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        match.routeNames,\n        initialRoutes,\n        parseQueryParams(path, match.parse)\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      if (!config.match) {\n        continue;\n      }\n\n      let didMatch = true;\n      const matchParts = config.match.split('/');\n      const remainingParts = remaining.split('/');\n\n      // we check if remaining path has enough segments to be handled with this pattern\n      if (config.pattern.split('/').length > remainingParts.length) {\n        continue;\n      }\n\n      // we keep info about the index of segment on which the params start\n      let paramsIndex = 0;\n      // the beginning of the remaining path should be the same as the part of config before params\n      for (paramsIndex; paramsIndex < matchParts.length; paramsIndex++) {\n        if (matchParts[paramsIndex] !== remainingParts[paramsIndex]) {\n          didMatch = false;\n          break;\n        }\n      }\n\n      // If the first part of the path matches, we need to extract params from the path\n      if (didMatch) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = remainingParts[i + paramsIndex]; // The param segments start from the end of matched part\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // if pattern and remaining path have same amount of segments, there should be nothing left\n        if (config.pattern.split('/').length === remainingParts.length) {\n          remaining = '';\n        } else {\n          // For each segment of the pattern, remove one segment from remaining path\n          let i = config.pattern.split('/').length;\n          while (i--) {\n            remaining = remaining.substr(remaining.indexOf('/') + 1);\n          }\n        }\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = createNestedStateObject(routeNames, initialRoutes, params);\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const route = findFocusedRoute(current);\n  const params = parseQueryParams(\n    path,\n    findParseConfigForRoute(route.name, configs)\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    configs.push(createConfigItem(key, routeNames, value));\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof value.path === 'string') {\n      configs.push(createConfigItem(key, routeNames, value.path, value.parse));\n    }\n\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  // part being matched ends on the first param\n  const match = pattern !== '' ? pattern.split('/:')[0] : null;\n\n  return {\n    screen,\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createStateObject(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n\nfunction createNestedStateObject(\n  routeNames: string[],\n  initialRoutes: InitialRouteConfig[],\n  params: object | undefined\n) {\n  let state: InitialState;\n  let routeName = routeNames.shift() as string;\n  let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n  state = createStateObject(\n    initialRoute,\n    routeName,\n    routeNames.length === 0,\n    params\n  );\n\n  if (routeNames.length > 0) {\n    let nestedState = state;\n\n    while ((routeName = routeNames.shift() as string)) {\n      initialRoute = findInitialRoute(routeName, initialRoutes);\n      nestedState.routes[nestedState.index || 0].state = createStateObject(\n        initialRoute,\n        routeName,\n        routeNames.length === 0,\n        params\n      );\n      if (routeNames.length > 0) {\n        nestedState = nestedState.routes[nestedState.index || 0]\n          .state as InitialState;\n      }\n    }\n  }\n\n  return state;\n}\n\nfunction findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index || 0].state) {\n    // The query params apply to the deepest route\n    current = current.routes[current.index || 0].state;\n  }\n\n  const route = (current as PartialState<NavigationState>).routes[\n    current?.index || 0\n  ];\n\n  return route;\n}\n\nfunction parseQueryParams(\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (parseConfig[name] && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n"]}